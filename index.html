---
layout: default
---

<!DOCTYPE html>
<html>
<body>
<h1>Portfolio</h1>
<h2>Self-Assessment:</h2>
<p>I started this degree with little to no knowledge about computer science. I was making a career change, and I was out of my element. As each semester progressed, I felt more and more comfortable and confident with my ability to not only meet but exceed all requirements on each project. In developing this ePortfolio, I aim to demonstrate the skills and strengths I have gained in various advanced concepts.
</p>
<p>Specific artifacts highlight a variety of coding standards and best practices as well as deeper topics. The creation of coursework throughout the program, and more specifically enhancing these creations throughout the portfolio, has showcased learning in embedded systems, data structures, and databases. Additionally coding best practices and a security mindset have been adopted regardless of setting.
</p>
<p>There are a few overarching skillsets adopted that do not directly relate to just one coding project. This includes skills such as collaborating in a team environment as well as communicating with various team members effectively. The ability to collaborate in a team environment is an imperative skill to success. Throughout a variety of differing project management methodologies there is a consistent undertone present: a confluence of people with various backgrounds and disciplines. This persistent fact places an importance upon this skill that transcends individual organizations or project management styles. The act of communicating with stakeholders highlights another important skill. This skill is underpinned with the ability to recognize various groups’ interests apart from your own. An ability to communicate clearly and an openness to feedback are necessary. This skill therefore also speaks broadly on one’s ability to convey technical information to non-technical audiences.
</p>
<p>Software engineering principles/best practices and security encompass more overarching principles, although more directly focused on specific coding projects. Security is at the forefront of development and a continual evolving thought. Reviewing data structures and algorithms in regard to designing and solving a solution to a problem involves managing trade-offs and ultimately having a keen understanding of the client’s needs. These trade-offs can be given metrics for comparisons and selections to be made, such as runtimes, costs, etc. 
</p>
<h3>Artifact Introduction</h3>
<p>The artifacts selected for this repository were chosen as they culminate into an exemplar of all these relevant skills. Specifically, the artifacts chosen for the software design and engineering and the algorithms and data structures/databases categories were an embedded smart thermostat and a course planner program respectively.
</p>
<p>The first artifact reflected on the skills gained through one of my more recent courses; Emerging systems. Selecting this artifact and utilizing embedded systems, peripherals and tools, and coding techniques (i.e. a task scheduler) to enhance the product, showcased the ability to use techniques and tools to design and develop exemplary solutions. A deeper understanding of embedded systems is displayed through thorough code enhancement, representing a skillset more pertinent to today’s increase in IoT devices. Coding standards and best practices are highlighted through consistency, detailed documentation and readability, maintainability, and reusability.
</p>
<p>The second artifact showcased strong skill sets in a variety of categories through various enhancements. Originally, the Course Planner was developed roughly halfway through this degree. The first enhancement reflected on a deliberation of factors and a selection of an algorithm data structure, underlying structure, and the creation of an algorithm to support the use of the structure. In doing so, it showcases the ability to design and use algorithmic principles while evaluating solutions and managing trade-offs. This enhancement also demonstrates a strong understanding of security concepts. The second enhancement dives deeper into the inclusion and improvements made through the use of database concepts, showcasing innovative techniques for the purpose of implementing a solution that will deliver a higher value product. Demonstrating the understanding of various database libraries and the selection of SQLite to meet specific system requirements while implementing data manipulation functionality highlights advanced understanding of database concepts. 
</p>
<h2>Code Review:</h2>
<p>A review of the original artifact code can be found
<a href="https://youtu.be/h_gcybcBZAg">here.</a>
  This includes the plans for modification and enhancement of the artifacts. 
</p>
<i>The third artifact was not used as a the second artifact was more suitably used to implement a databse.
</i>
<h1>Narratives</h1>
<h2>Category One: Software Design and Engineering</h2>
<a href="https://github.com/Nsilvestro/Nsilvestro.github.io/tree/main/Artifact%20One%20Enhancement/gpiointerrupt_CC3220SF_LAUNCHXL_nortos_gcc">Category One Enhancement</a>
<h3>Artifact Description:</h3>
<p>The artifact in use is the final project from the emerging systems architecture and technologies course. This project was created as an example of the embedded systems knowledge gained. The code in the project was intended to create and prototype an embedded system smart thermostat. Through the use of peripherals, a current temperature would be sensed, compared with a setpoint temperature, and if necessary, the LED would light (indicating a heating system turning on). Two buttons on the TI board were used to manipulate the setpoint temperature.
</p>
<h3>Inclusion:</h3>
<p>This artifact was selected for inclusion in the ePortfolio as experience with programming for embedded systems appeared to be a self-promoting skillset, especially with pertinence to IoT devices.
Within the artifact, improvements to the code’s efficiency through exchanging the current conditional statements for a task scheduler as well as generally altering the code to conform to code review improvements will showcase an ability to deliver a product that accomplishes industry specific goals (such as a smart thermostat that simulates data being sent to a server via WIFI).
</p>
<h3>Enhancement Process:</h3>
<p>Pin configuration: In attempting to make the main functional enhancement, the AC counterpart to the current heating system prototype, I was able to learn more about the hardware itself. In configuring the hardware and pins for peripheral objects, I found that you are rather limited by the pins available on the board. Multiple LEDs have been used successfully in previous work: using pulse width modulation (PWM) to create morse code messages using two LEDs and using GPIO with two LEDs. In the former PWM example, the LEDs were configured using the I2C pin. In the latter GPIO example, the red LED has a pin available for selection in pin configuration (P64/29). Neither the yellow nor green LEDs have a similar option under GPIO pin configuration (although both have a hardware option). In order to use a second LED with the red LED in the past using GPIO, the second LED pin was configured as the I2C pin (P02/10) as well. In the previous projects the I2C peripheral was not in use, whereas in this project it is integral. The workarounds I was able to research involved more hardware, such as a GPIO expander or PWM controller. A seemingly simple approach to configuring a logically similar but opposite AC counterpart to the heat system functionality would require additional hardware and hardware integration that would be outside of the scope of this software category.
</p>
<p>Task Scheduler: As part of the enhancements for this project, I implemented the use of a task scheduler to increase efficiency. In order to accomplish this, I created a structure to hold relevant attributes (such as task period, elapsed time, and task function) of a task (button checking, comparing temperatures, and outputting data) in the program. Additionally, a task initializer function and a task scheduler function were created to populate the tasks and their attributes, and to handle the main task scheduler for loop. This involved moving repetitive local variables throughout the code to global variable scope and decreasing the overall amount of declared variables. This also involved creating individual task functions with respective functionality. One issue encountered was when calling the task functions in the task scheduler function originally. After researching and experimenting around the error, I defined a function type and used this type in the overall task structure to resolve the issue. Ultimately this implementation increased the efficiency of the code, while decreasing the overall amount of repetitive code in the main function.
</p>
<h2>Category Two: Algorithms & Data Structures</h2>
<a href="https://github.com/Nsilvestro/Nsilvestro.github.io/tree/main/Artifact%20Two%20Enhancement%20One/CoursePlannerEnhancement.1">Category Two Enhancement</a>
<h3>Artifact Description:</h3>
<p>The artifact selected for the category of algorithms and data structures was the course planner project from CS-300 course (Data Structures and Algorithms). The projects focused on aiding the “ABC University” client on developing a program to aid academic advisors in assisting students. The program loads a file of course information, in this case a list of computer science courses, and allows advisors to print schedules, or search for a specific course. Ultimately, this project was about determining appropriate data structures for a client’s needs. 
</p>
<h3>Inclusion:</h3>
<p>Initially, after reviewing the category title, it felt fitting to review the data structures and algorithms course projects. I selected this artifact as it strongly aligned with a specific course outcome. To align with the outcome, creating algorithms with selected data structures lends to solving problems using algorithmic principles, while more importantly reviewing efficiency and cost will involve reviewing and weighing trade-offs (such as worst cases, best cases, total cost, etc.). Overall improvements include a focus on efficiency: reviewing and selecting the data structure and the responsible code for the data structure, as well as maintaining the code structurally.
</p>
<h3>Enhancement Process:</h3>
<p>Aspects of the code were restructured, such as creating individual specific functions from repetitive code that could be separated (ex. the menu of options). Additional methods were created and documented as well. These include the display course outlook, file path checker, duplicate file checker, and course key format check functions.
</p>
<p>The display course outlook function was created to bring additional functionality to the program in general. This method allows a user or advisor to view the information more meaningfully for some classes, allowing them to detail which future classes will be benefited from a current class.
</p>
<p>The file path checker was created with security in mind. This function aims to validate the file path provided from the user, checking that the proper extension is provided as well as validating the existence of the file before attempting to load in subsequent lines of code. One challenge I ran into here was one of my own logical errors. I had attempted to pass the csv path to the function to validate these aspects. Initially, I was attempting to alter the csv path in a function’s scope without returning the altered path. I restructured the code and locations in the code where user input was accepted to remediate this.
</p>
<p>The duplicate file checker was created to notify users when they were attempting to load a file that had already been loaded. The course key format checker aims to validate the course number provided by users during various menu options. This function verifies the input’s length and alphanumeric pattern ensuring that they match the course numbers loaded. One challenge I encountered here was the decision to use manual format checking or to use regular expressions to verify the format. In weighing the cost of the speed of the two, information that I could find on the topic tended to lean towards the conclusion that regular expressions can be more costly to time.
</p>
<p>Additionally, the time complexity and cost of the data structures were weighed again. The use of the hash table seems most efficient and consistent. I would continue to recommend using the hash table for the required functionality of the course system. Beginning with the best-case runtime for creating and storing course objects (as the worst case was the same for reviewed structures), the hash table is able to insert more efficiently than the tree and more consistently than the vector through the use of the hashing function, as opposed to a pushback. The use of an efficient hash function on a unique identifier (such as a course number) in combination with a chaining approach would lead to a sorted table as well. Lastly, a worst-case search of a hash table is comparable to the vector or tree (linear), however the average search for a hash table exceeds the alternative choices.
</p>
<h2>Category Three: Databases</h2>
<a href="https://github.com/Nsilvestro/Nsilvestro.github.io/tree/main/Artifact%20Two%20Enhancement%20Two/CoursePlannerEnhancement.2">Category Three Enhancement</a>
<h3>Artifact Description:</h3>
<p>The course planner project detailed above.</p>
<h3>Inclusion:</h3>
<p>I selected this artifact for use as it was an applicable scenario that would benefit from the use of a database for this category, as well as a greater demonstration of growth. Overall necessary underlying fixes were required for this artifact to promote a security mindset. Utilizing database concepts, an SQLite database will be implemented and configured to further enhance the usability of the application. Other improvements include adding more advanced concepts to the methods related to the database. Lastly, the code was maintained structurally and documented through the addition of the aforementioned enhancements.
</p>
<h3>Enhancement Process:</h3>
<p>Enhancements were made to introduce a database to the course planner program. SQLite was chosen as the database library. After reviewing available options, this choice was selected for its ease of use, embeddability, and serverless nature. For the purposes of this project, embeddability was beneficial, as a database was to be added into an existing C++ application. It was somewhat challenging to setup and configure the necessary components throughout the file structure and properties of the project.
Otherwise, my previous experience working with databases in this program was with full stack development where MongoDB was used. In that scenario the database was not serverless and relied upon running prior. This factor also contributed to the choice of using SQLite.
</p>
<p>I deliberated on if the purpose of the database should be but ultimately decided that it should be used for student planning. The database allows a student user to create a schedule of courses that persists over time, while the original application remains as a means to parse data files from various sources and store data temporarily.
</p>
<p>I created multiple functions for the purpose of accessing and manipulating data stored in the database: display student menu, connect to database, create student schedule, access student schedule, add courses to student schedule, and remove courses from student schedule. Display student menu was created to display a new menu of options for the database. Connect to database attempts to connect to the database, while handling errors when unable to connect. Create student schedule creates a table in the database if one does not already exist, with error handling. Access student schedule displays the courses currently contained in the database table. The remaining functions, for adding and deleting courses from the database, are similar. A course number is taken as user input, and an attempt is made to either insert or delete the course (if found from the course number) from the student schedule. Error handling is implemented in both.
</p>
<p>Additionally, handling of the new menu choices is accomplished utilizing a nested switch case within the main menu’s switch case. This posed a challenge initially, as I had to contend with some scope related errors.
</p>
<p>Ultimately, the code enhancements for this category became the most modular and maintainable components of the application. I learned how to incorporate a created data structure into queries and integrate a database into an existing application. 
</p>
</body>
</html>
